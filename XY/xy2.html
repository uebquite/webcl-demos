<html><head>

<!-- based on XY Model http://www.ibiblio.org/e-notes/webcl/mc/xy2.html -->

<TITLE>XY model. Modified chess-board algorithm</TITLE>

<script src="../common/gl.js" type="text/javascript"></script>

<script id="clXY" type="text/x-opencl">

constant int n = 512;
constant float h = 1.0f/512.0f, hy = 2.0f/512.0f;

float en( float x ){
  const float pi2 = M_PI_F + M_PI_F;
  return native_cos(pi2 * x);
}

__kernel void kSpinW(read_only image2d_t sB, read_only image2d_t sW,
    write_only image2d_t sW1, global uint* rand, float rT ) {
  const sampler_t samp =
    CLK_NORMALIZED_COORDS_TRUE|CLK_ADDRESS_REPEAT|CLK_FILTER_NEAREST;
  int ix = get_global_id(0),  iy = get_global_id(1),  t = ix + n*iy;
  float x = h*(ix + .5f),  y = hy*(iy + .5f);
  float s0 = read_imagef(sW, samp, (float2)(x, y)).x;
  uint r = 1664525u * rand[t] + 1013904223u;
  float snew = s0 + (r/4294967295.0f - .5f)*.1f + 1.0f;
  snew -= floor(snew);
  r = 1664525u * r + 1013904223u;
  rand[t] = r;

  float sh = ((ix & 1) == 0) ? 0.0f : hy;
  float si = read_imagef(sB, samp, (float2)(x, y + hy)).x;
  float e = en(si - s0) - en(si - snew);
  si = read_imagef(sB, samp, (float2)(x, y)).x;
  e += en(si - s0) - en(si - snew);
  si = read_imagef(sB, samp, (float2)(x + h, y + sh)).x;
  e += en(si - s0) - en(si - snew);
  si = read_imagef(sB, samp, (float2)(x - h, y + sh)).x;
  e += en(si - s0) - en(si - snew);

  if (r > 4294967295.0f*native_exp(-e*rT)) snew = s0;
  write_imagef(sW1, (int2)(ix, iy), (float4)(snew, .0f,.0f,.0f));
}

__kernel void kSpinB(read_only image2d_t sB, read_only image2d_t sW,
    write_only image2d_t sB1, global uint* rand, float rT ) {
  const sampler_t samp =
    CLK_NORMALIZED_COORDS_TRUE|CLK_ADDRESS_REPEAT|CLK_FILTER_NEAREST;
  int ix = get_global_id(0),  iy = get_global_id(1),  t = ix + n*iy;
  float x = h*(ix + .5f),  y = hy*(iy + .5f);
  float s0 = read_imagef(sB, samp, (float2)(x, y)).x;
  uint r = 1664525u * rand[t] + 1013904223u;
  float snew = s0 + (r/4294967295.0f - .5f)*.1f + 1.0f;
  snew -= floor(snew);
  r = 1664525u * r + 1013904223u;
  rand[t] = r;

  float sh = ((ix & 1) == 0) ? -hy : 0.0f;
  float si = read_imagef(sW, samp, (float2)(x, y)).x;
  float e = en(si - s0) - en(si - snew);
  si = read_imagef(sW, samp, (float2)(x, y - hy)).x;
  e += en(si - s0) - en(si - snew);
  si = read_imagef(sW, samp, (float2)(x + h, y + sh)).x;
  e += en(si - s0) - en(si - snew);
  si = read_imagef(sW, samp, (float2)(x - h, y + sh)).x;
  e += en(si - s0) - en(si - snew);

  if (r > 4294967295.0f*native_exp(-e*rT)) snew = s0;
  write_imagef(sB1, (int2)(ix, iy), (float4)(snew, .0f,.0f,.0f));
}

int iClamp(int i){
  return min( max( 0, i), 255 );
}

__kernel void kPix(read_only image2d_t sB, read_only image2d_t sW,
    global uchar4* pix) {
  const sampler_t samp =
    CLK_NORMALIZED_COORDS_FALSE|CLK_ADDRESS_CLAMP|CLK_FILTER_NEAREST;
  int x = get_global_id(0),  y = get_global_id(1);
  int y2 = y >> 1;
  int c;
  if ( ((x + y) & 1) == 0)
    c = (int)( read_imagef(sB, samp, (int2)(x, y2) ).x * 1536.0f );
  else c = (int)( read_imagef(sW, samp, (int2)(x, y2 ) ).x * 1536.0f );
  pix[x + n*y] = (uchar4)(
    iClamp( (int)abs(c - 768) - 256 ),
    iClamp( 512 - (int)abs(c - 512) ),
    iClamp( 512 - (int)abs(c - 1024) ),
    255);
}
</script>

<script type="text/javascript">

function loadKernel ( id ){
    var shaderScript = document.getElementById ( id );
    var str = "";
    var k = shaderScript.firstChild;

    while (k){
        if ( k.nodeType == 3 ) str += k.textContent;
        k = k.nextSibling;
    }

    return str;
}

var T = .02, n = 512, n2 = n/2,  it = 100, bufSize = 4*n*n, ev,
    ctx_c, frames = 0, animation = "animate", time, delay = 0, randByteLength = 4*n*n2;

var kSpinB, kSpinW, kPix, cmdQueue, iSpinB, iSpinB1, iSpinW, iSpinW1,
    bufPix, outBuffer, iTemp, spin;

var SPIN_GLOBAL_SIZE = new Int32Array([n, n2]);
var PIX_GLOBAL_SIZE = new Int32Array([n, n]);
var IMAGE_ORIGIN = new Int32Array([0, 0, 0]);
var IMAGE_REGION = new Int32Array([n, n2, 1]);

function CL_rand () {
  try {

      if (window.webcl == undefined) {
      alert("Unfortunately your system does not support WebCL");
      return false;
    }

    var platforms = webcl.getPlatforms();

    if (!platforms) {
        alert("No WebCL platform found in your system")
        return false;
    }

    var devices = platforms[0].getDevices(webcl.DEVICE_TYPE_GPU);

    if (!devices) {
        alert("No device found in your system")
        return false;
    }

    var device = devices[0];

    var ctxProps = {platform: platforms[0], devices: [device],
            deviceType: webcl.DEVICE_TYPE_GPU, shareGroup: 0, hint: null};

    var ctx = webcl.createContext(ctxProps);

    bufRand = ctx.createBuffer (webcl.MEM_READ_WRITE,randByteLength);
    var format = {channelOrder:webcl.RGBA, channelDataType:webcl.FLOAT,
            width: n, height: n2, rowPitch: 0};
    iSpinB  = ctx.createImage(webcl.MEM_READ_WRITE, format);
    iSpinB1 = ctx.createImage(webcl.MEM_READ_WRITE, format);
    iSpinW  = ctx.createImage(webcl.MEM_READ_WRITE, format);
    iSpinW1 = ctx.createImage(webcl.MEM_READ_WRITE, format);
    iTemp   = ctx.createImage(webcl.MEM_READ_WRITE, format);
    bufPix  = ctx.createBuffer (webcl.MEM_WRITE_ONLY, bufSize);

    var kernelSrc = loadKernel("clXY");
    var program = ctx.createProgram(kernelSrc);

    try {
      program.build([device]);
    } catch(e) {
      alert ("Failed to build WebCL program. Error "
        + program.getBuildInfo (device,
           webcl.PROGRAM_BUILD_STATUS)
        + ":  " + program.getBuildInfo (device,
           webcl.PROGRAM_BUILD_LOG));
      throw e;
    }

    kSpinB = program.createKernel ("kSpinB");
    kSpinB.setArg(3, bufRand);
    kSpinB.setArg(4, 1/T, WebCLKernelArgumentTypes.FLOAT);

    kSpinW = program.createKernel ("kSpinW");
    kSpinW.setArg(3, bufRand);
    kSpinW.setArg(4, 1/T, WebCLKernelArgumentTypes.FLOAT);

    kPix = program.createKernel("kPix");
    kPix.setArg(2, bufPix);

    var UIrand = new Uint32Array(randByteLength);
    for ( var i = 0; i <randByteLength;  i++ ) {
        UIrand[i] = Math.floor(Math.random() * 4294967295);
    }

    cmdQueue = ctx.createCommandQueue (device, 0);

    initImageSpin();
    
    cmdQueue.enqueueWriteBuffer(bufRand, true, 0,randByteLength, UIrand);
    outBuffer = new Uint8Array(bufSize);
  } catch(e) {
    document.getElementById("output").innerHTML
      += "<h3>ERROR:</h3><pre style=\"color:red;\">" + e.message + "</pre>";
    console.error(e);
    throw e;
  }
  var canvas = document.getElementById("c");
  init_gl(canvas);
  time = new Date().getTime();
  setInterval(fr, 500);
  anim();
}


function randomSpin() {

    /* Like a singleton */
    if (!spin) {
        spin = new Float32Array(n*n2);
    }

    for ( var i = 0; i < n*n2;  i++ ) {
        spin[i] = Math.random();
    }

    return spin;
}

function draw(){

  for ( var i = 0; i < it;  i++ ){
    kSpinW.setArg(0, iSpinB);
    kSpinW.setArg(1, iSpinW);
    kSpinW.setArg(2, iSpinW1);

    try {
        cmdQueue.enqueueNDRangeKernel(kSpinW, null, SPIN_GLOBAL_SIZE, null);
    } catch (e) {
        console.error(e);
        throw e;
    }
    cmdQueue.flush();

    /* Swap images */
    cmdQueue.enqueueCopyImage(iSpinW1, iTemp,   IMAGE_ORIGIN, IMAGE_ORIGIN, IMAGE_REGION);
    cmdQueue.enqueueCopyImage(iSpinW,  iSpinW1, IMAGE_ORIGIN, IMAGE_ORIGIN, IMAGE_REGION);
    cmdQueue.enqueueCopyImage(iTemp,   iSpinW,  IMAGE_ORIGIN, IMAGE_ORIGIN, IMAGE_REGION);

    kSpinB.setArg(0, iSpinB);
    kSpinB.setArg(1, iSpinW);
    kSpinB.setArg(2, iSpinB1);

    cmdQueue.enqueueNDRangeKernel(kSpinB, null, SPIN_GLOBAL_SIZE, null);
    cmdQueue.flush();

    /* Swap images */
    cmdQueue.enqueueCopyImage(iSpinB1, iTemp,   IMAGE_ORIGIN, IMAGE_ORIGIN, IMAGE_REGION);
    cmdQueue.enqueueCopyImage(iSpinB,  iSpinB1, IMAGE_ORIGIN, IMAGE_ORIGIN, IMAGE_REGION);
    cmdQueue.enqueueCopyImage(iTemp,   iSpinB,  IMAGE_ORIGIN, IMAGE_ORIGIN, IMAGE_REGION);
  }

  kPix.setArg(0, iSpinB);
  kPix.setArg(1, iSpinW);

  cmdQueue.enqueueNDRangeKernel(kPix, null, PIX_GLOBAL_SIZE, null);
  cmdQueue.enqueueReadBuffer (bufPix, true, 0, bufSize, outBuffer);
  cmdQueue.finish();

  try {
      draw_gl(n, n, outBuffer);
      frames++;
  } catch (e) {
      console.error(e);
      throw e;
  }
}

/**
 *  Used create random spins to init animation
 */
function initImageSpin() {
    cmdQueue.enqueueWriteImage(iSpinB, true, IMAGE_ORIGIN, IMAGE_REGION, 0, randomSpin());
    cmdQueue.enqueueWriteImage(iSpinW, true, IMAGE_ORIGIN, IMAGE_REGION, 0, randomSpin());
}

function anim(){
   draw();
   switch ( animation ){
     case "reset":
      initImageSpin();
      animation = "animate";
     case "animate":
       if (delay == 0) requestAnimationFrame(anim);
       else setTimeout("requestAnimFrame(anim)", delay);
       break;
     case "stop":
       break;
   }
}
function run(v) {
  if( animation == "animate" ){
    animation = "stop";
    document.getElementById('runBtn').value = "Run ";}
  else{
    animation = "animate";
    document.getElementById('runBtn').value = "Stop";
    anim();
  }
}
function reset() {
  if( animation == "stop" ){
    animation = "reset";
    document.getElementById('runBtn').value = "Stop";
    anim();}
  else animation = "reset";
}
function setDelay(val) {
  delay = parseInt(val);
}
function fr(){
  var ti = new Date().getTime();
  var fps = Math.round(1000*frames/(ti - time));
  document.getElementById("framerate").value = fps;
  frames = 0;  time = ti;
}
function setT(v){
  var T = v.valueOf();
  kSpinB.setKernelArg (4, 1/T, WebCL.types.FLOAT);
  kSpinW.setKernelArg (4, 1/T, WebCL.types.FLOAT);
}
function setIt(val) {
  it = parseInt(val);
}
</script>
<style type="text/css">
  H1{ font-size: 120%; color: green}
  H2{ font-size: 100%; color: green}
  pre{ color: darkblue}
</style>
</head><body onload="CL_rand ()">

<h1>XY model. Modified chess-board algorithm</h1>

<p id="output"></p>
<canvas id="c" width="512" height="512"></canvas>
<br><button onclick="reset()">Reset</button>
<input type="button" onclick="run()" value="Stop" size="1" id="runBtn">
T<input size="4" value="0.02" onchange="setT( this.value )">
It<input size="1" value="100" onchange="setIt( this.value )">
delay<input size="2" value="0" onchange="setDelay( this.value )">
fps<input size="2" id="framerate">

<p>GPU based Monte-Carlo simulation of the XY model on the square 512&times;512
grid. <i>it</i> is the number of MC iterations per frame.

<p>Different colors correspond to different spin phases.
Therefore vortices appear as point deffects where all colors meet
together (see <a href="../../Perc/xy.htm">Vortices in the XY model</a>).
<table><tr><td>
<img width="250" height="150" title="xy" src="fig/xy.jpg">
</td><td>
You can watch vortices formation from random spin configuration.
Vortex and anti-vortex attract and annihilate (in a while) each other.
Set temperature <i>T = 0.002</i> to cool down vortices.
For <i>T &lt; 0</i> you will get the antiferromagnetic model.
</td></tr></table>


<hr><a href="../webcl.htm">WebCL Demos</a>
&nbsp; &nbsp; <i>updated</i> 17 Sep 2011

</body></html>
